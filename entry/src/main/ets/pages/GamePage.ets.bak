/**
 * æ¸¸æˆä¸»é¡µé¢
 * æ ¸å¿ƒæ¸¸æˆçŽ©æ³•ç•Œé¢
 */

import { Navigator } from '../utils/Navigator';
import { LevelRepository } from '../repositories/LevelRepository';
import { UserRepository } from '../repositories/UserRepository';
import { GameService } from '../services/GameService';
import { LevelService } from '../services/LevelService';
import { GameState, createInitialGameState, GameStatus } from '../models/GameState';
import { Attempt } from '../models/Attempt';
import { Color } from '../constants/Colors';
import { GuessRow } from '../components/GuessRow';
import { GameColorPicker } from '../components/GameColorPicker';
import { GameConfig } from '../constants/GameConfig';
import { Level } from '../models/Level';
import { ResponsiveUtils, RF, RSP, RS } from '../utils/ResponsiveUtils';

interface GamePageParamsType {
  levelId?: number;
  practiceMode?: boolean;
}

@Entry
@Component
struct GamePage {
  @State gameState: GameState | null = null;
  @State levelId: number = 1;
  @State currentSlotIndex: number = 0;
  @State isLoading: boolean = true;

  async aboutToAppear() {
    ResponsiveUtils.init();
    await this.loadGameFromParams();
  }

  /**
   * é¡µé¢æ˜¾ç¤ºæ—¶é‡æ–°åŠ è½½æ•°æ®
   * ä¿®å¤åˆ‡æ¢é¡µé¢åŽæ•°æ®ä¸åˆ·æ–°çš„bug
   */
  async onPageShow() {
    console.log('=== GamePage onPageShow ===');
    // æ¯æ¬¡é¡µé¢æ˜¾ç¤ºæ—¶é‡æ–°åŠ è½½æ•°æ®ï¼Œç¡®ä¿æ•°æ®æ–°é²œ
    await this.loadGameFromParams();
  }

  /**
   * ä»Žè·¯ç”±å‚æ•°åŠ è½½æ¸¸æˆ
   */
  async loadGameFromParams() {
    // ä»Žè·¯ç”±å‚æ•°èŽ·å–å…³å¡ID
    const params = Navigator.getParams() as GamePageParamsType;
    const levelIdParam = params?.levelId || 1;
    const isPracticeMode = params?.practiceMode || false;

    console.log(`=== loadGameFromParams: levelId=${levelIdParam}, isPracticeMode=${isPracticeMode} ===`);

    await this.initGame(levelIdParam, isPracticeMode);
  }

  /**
   * åˆå§‹åŒ–æ¸¸æˆ
   */
  async initGame(levelId: number, isPracticeMode: boolean) {
    try {
      let level: Level;

      if (isPracticeMode) {
        // ç»ƒä¹ æ¨¡å¼ï¼šæ ¹æ®ç”¨æˆ·è¿›åº¦ç”Ÿæˆåˆé€‚éš¾åº¦çš„å…³å¡
        const userProgress = await UserRepository.getUserProgress();
        let practiceColorCount = 4;

        // æ ¹æ®å·²è§£é”å…³å¡å†³å®šç»ƒä¹ æ¨¡å¼é¢œè‰²æ•°é‡
        const totalUnlocked = userProgress.easyUnlocked + userProgress.hardUnlocked;
        if (totalUnlocked > 100) {
          practiceColorCount = 6; // å·²è§£é”6è‰²å…³å¡
        } else if (totalUnlocked > 50) {
          practiceColorCount = 5; // å·²è§£é”5è‰²å…³å¡
        }

        console.log(`=== Practice mode: using ${practiceColorCount} colors based on unlocked levels: easy=${userProgress.easyUnlocked}, hard=${userProgress.hardUnlocked} ===`);

        level = LevelService.generatePracticeLevel(practiceColorCount);
      } else {
        // æ™®é€šæ¨¡å¼ï¼šåŠ è½½å…³å¡
        level = await LevelRepository.getLevel(levelId);
      }

      this.levelId = levelId;
      this.gameState = GameService.createGame(level, isPracticeMode ? 'practice' : 'solo');
      this.currentSlotIndex = 0;
      this.isLoading = false;

      console.log(`=== Game initialized: colorCount=${level.colorCount}, password=[${level.password.join(', ')}] ===`);
    } catch (error) {
      console.error('Failed to init game:', error);
      this.isLoading = false;
    }
  }

  build() {
    Column() {
      if (this.isLoading || !this.gameState) {
        // åŠ è½½çŠ¶æ€
        Column() {
          LoadingProgress()
            .width(ResponsiveUtils.rs(50))
            .height(ResponsiveUtils.rs(50))
            .color('#2196F3')
          Text('åŠ è½½å…³å¡ä¸­...')
            .fontSize(ResponsiveUtils.rf(RF.BODY_M))
            .fontColor('#757575')
            .margin({ top: ResponsiveUtils.rsp(RSP.M) })
        }
        .width('100%')
        .height('100%')
        .justifyContent(FlexAlign.Center)
      } else {
        // é¡¶éƒ¨ä¿¡æ¯æ 
        Row() {
          // è¿”å›žæŒ‰é’®
          Text('âœ•')
            .fontSize(ResponsiveUtils.rf(RF.BODY_L))
            .fontColor('#757575')
            .onClick(() => {
              Navigator.pop();
            })

          // å…³å¡ä¿¡æ¯
          Column() {
            Text(`å…³å¡ ${this.levelId}`)
              .fontSize(ResponsiveUtils.rf(RF.BODY_L))
              .fontWeight(FontWeight.Medium)

            Text(`å‰©ä½™æ¬¡æ•°: ${GameService.getRemainingAttempts(this.gameState!)}`)
              .fontSize(ResponsiveUtils.rf(RF.BODY_S))
              .fontColor('#757575')
              .margin({ top: ResponsiveUtils.rsp(RSP.XXS) })
          }
          .alignItems(HorizontalAlign.Start)
          .layoutWeight(1)
          .margin({ left: ResponsiveUtils.rsp(RSP.XS) })

          // æç¤ºæŒ‰é’®
          if (this.gameState.level.hintMode === 'mapped') {
            Text('ðŸ’¡')
              .fontSize(ResponsiveUtils.rf(RF.BODY_L))
              .onClick(() => {
                // TODO: å®žçŽ°æç¤ºåŠŸèƒ½
              })
          }
        }
        .width('100%')
        .padding({ left: ResponsiveUtils.rsp(RSP.M), right: ResponsiveUtils.rsp(RSP.M), top: ResponsiveUtils.rsp(RSP.XS), bottom: ResponsiveUtils.rsp(RSP.XS) })
        .backgroundColor('#FFFFFF')

        // çŒœæµ‹åŽ†å²åŒºåŸŸ
        Scroll() {
          Column() {
            // æ˜¾ç¤ºæ‰€æœ‰åŽ†å²çŒœæµ‹
            ForEach(this.gameState.attempts, (attempt: Attempt, index: number) => {
              GuessRow({
                guess: attempt.guess,
                hits: attempt.hits,
                pseudoHits: attempt.pseudoHits,
                showHints: true
              })
            }, (attempt: Attempt, index: number) => `attempt_${index}`)

            // å½“å‰æ­£åœ¨è¾“å…¥çš„çŒœæµ‹
            GuessRow({
              guess: this.gameState.currentGuess.map(c => c || null) as Color[],
              hits: 0,
              pseudoHits: 0,
              isActive: true,
              showHints: false
            })
          }
          .width('100%')
        }
        .layoutWeight(1)
        .scrollBar(BarState.Auto)
        .align(Alignment.Bottom)

        // å½“å‰é€‰æ‹©æ§½ä½æŒ‡ç¤ºå™¨
        Row() {
          ForEach([0, 1, 2, 3], (index: number) => {
            Column() {
              Circle()
                .fill(this.currentSlotIndex === index ? '#2196F3' : '#E0E0E0')
                .width(ResponsiveUtils.rs(RS.DOT_SIZE))
                .height(ResponsiveUtils.rs(RS.DOT_SIZE))
            }
            .layoutWeight(1)
          })
        }
        .width('100%')
        .padding(ResponsiveUtils.rsp(RSP.XS))
        .backgroundColor('#F5F5F5')

        // é¢œè‰²é€‰æ‹©å™¨
        Column() {
          GameColorPicker({
            availableColors: this.getAvailableColors(),
            selectedColor: this.getSelectedColor(),
            onColorSelect: (color: Color) => {
              this.onColorSelect(color);
            }
          })

          // æ“ä½œæŒ‰é’®
          Row({ space: ResponsiveUtils.rsp(RSP.XS) }) {
            // æ¸…ç©ºæŒ‰é’®
            Button('æ¸…ç©º')
              .type(ButtonType.Normal)
              .backgroundColor('#F5F5F5')
              .fontColor('#212121')
              .borderRadius(8)
              .layoutWeight(1)
              .onClick(() => {
                this.clearGuess();
              })

            // ç¡®è®¤æŒ‰é’®
            Button('ç¡®è®¤')
              .type(ButtonType.Normal)
              .backgroundColor('#2196F3')
              .fontColor('#FFFFFF')
              .borderRadius(8)
              .layoutWeight(1)
              .enabled(GameService.isCurrentGuessComplete(this.gameState!))
              .onClick(() => {
                this.submitGuess();
              })
          }
          .width('90%')
          .padding({ bottom: ResponsiveUtils.rsp(RSP.M) })
        }
        .backgroundColor('#FFFFFF')
      }
    }
    .width('100%')
    .height('100%')
    .backgroundColor('#FAFAFA')
  }

  /**
   * èŽ·å–å¯ç”¨é¢œè‰²åˆ—è¡¨
   */
  private getAvailableColors(): Color[] {
    const allColors: Color[] = ['red', 'yellow', 'green', 'blue', 'purple', 'orange'];
    const availableColors = allColors.slice(0, this.gameState!.level.colorCount);

    console.log(`=== getAvailableColors: colorCount=${this.gameState!.level.colorCount}, colors=[${availableColors.join(', ')}] ===`);

    return availableColors;
  }

  /**
   * èŽ·å–å½“å‰é€‰ä¸­æ§½ä½çš„é¢œè‰²
   */
  private getSelectedColor(): Color | null {
    return this.gameState!.currentGuess[this.currentSlotIndex];
  }

  /**
   * é€‰æ‹©é¢œè‰²
   */
  private onColorSelect(color: Color) {
    if (this.currentSlotIndex >= 0 && this.currentSlotIndex < GameConfig.PASSWORD_LENGTH) {
      this.gameState = GameService.updateCurrentGuess(
        this.gameState!,
        this.currentSlotIndex,
        color
      );

      // è‡ªåŠ¨ç§»åŠ¨åˆ°ä¸‹ä¸€ä¸ªæ§½ä½
      if (this.currentSlotIndex < GameConfig.PASSWORD_LENGTH - 1) {
        this.currentSlotIndex++;
      }
    }
  }

  /**
   * æ¸…ç©ºå½“å‰çŒœæµ‹
   */
  private clearGuess() {
    this.gameState = GameService.clearCurrentGuess(this.gameState!);
    this.currentSlotIndex = 0;
  }

  /**
   * æäº¤çŒœæµ‹
   */
  private async submitGuess() {
    if (!this.gameState || !GameService.isCurrentGuessComplete(this.gameState)) {
      return;
    }

    // æäº¤çŒœæµ‹
    this.gameState = GameService.submitGuess(
      this.gameState,
      this.gameState.currentGuess as Color[]
    );

    // æ£€æŸ¥æ¸¸æˆæ˜¯å¦ç»“æŸ
    if (GameService.isGameEnd(this.gameState)) {
      await this.handleGameEnd();
    } else {
      // é‡ç½®æ§½ä½é€‰æ‹©
      this.currentSlotIndex = 0;
    }
  }

  /**
   * å¤„ç†æ¸¸æˆç»“æŸ
   */
  private async handleGameEnd() {
    if (!this.gameState) return;

    const isWin = GameService.isWin(this.gameState);
    const currentTime = Date.now();
    const timeSpent = currentTime - this.gameState.startTime;

    if (isWin) {
      // ä¿å­˜èƒœåˆ©ç»“æžœ
      await UserRepository.handleGameWin(
        this.levelId,
        this.gameState.attempts.length,
        this.gameState.level.maxAttempts
      );
    } else {
      // ä¿å­˜å¤±è´¥ç»“æžœ
      await UserRepository.handleGameLose();
    }

    // è·³è½¬åˆ°ç»“æžœé¡µé¢
    Navigator.pushResult({
      mode: this.gameState.mode,
      levelId: this.levelId,
      isWin,
      attempts: this.gameState.attempts.length,
      maxAttempts: this.gameState.level.maxAttempts,
      timeSpent,
      password: this.gameState.level.password
    });
  }
}
